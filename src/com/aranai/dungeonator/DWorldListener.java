package com.aranai.dungeonator;

import java.util.Arrays;
import java.util.HashSet;
import java.util.List;

import net.minecraft.server.WorldServer;

import org.bukkit.Chunk;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.World;
import org.bukkit.craftbukkit.CraftChunk;
import org.bukkit.craftbukkit.CraftWorld;
import org.bukkit.entity.Entity;
import org.bukkit.event.world.ChunkLoadEvent;
import org.bukkit.event.world.WorldListener;

import com.aranai.dungeonator.generator.DungeonChunkProvider;

public class DWorldListener extends WorldListener {
	
	/** Dungeonator plugin instance. */
	private Dungeonator plugin;
	
	private DungeonChunkProvider dcp;
	
	/** Debug field: flattened: flattened chunks */
	private HashSet<String> flattened = new HashSet<String>();
	private int fCount = 0;
	
	/**
	 * Instantiates a new world listener.
	 *
	 * @param plugin the Dungeonator plugin instance
	 */
	public DWorldListener(Dungeonator plugin)
	{
		this.plugin = plugin;
		
		plugin.py = 0;
		
		World world = plugin.getServer().getWorlds().get(0);
		Chunk chunks[] = world.getLoadedChunks();
		
		String worldName = world.getName();
		
		this.dcp = new DungeonChunkProvider(world, 0);
		((CraftWorld)world).getHandle().chunkProviderServer.chunkProvider = dcp;
		
		for(int ci = 0; ci < chunks.length; ci++)
		{
			Chunk c = chunks[ci];
			
			String hash = worldName+"."+c.getX()+"."+c.getZ();
			flattened.add(hash);
			
			System.out.print("[F:"+c.getX()+","+c.getZ() + " - " + hash + "]");
			
			this.flatten(world, c);
			
			// Unload chunk
			plugin.getServer().getWorlds().get(0).unloadChunk(c.getX(), c.getZ());
			
			chunks[ci] = null;
			
			if((ci % 50) == 0) { System.gc(); }
		}
		
		// DEBUG: Add sand block near spawn
		world.getBlockAt(0,1,0).setType(Material.SAND);
		world.getBlockAt(1,1,0).setType(Material.SAND);
		world.getBlockAt(1,1,1).setType(Material.SAND);
		world.getBlockAt(0,1,1).setType(Material.SAND);
		world.getBlockAt(1,1,-1).setType(Material.SAND);
		world.getBlockAt(0,1,-1).setType(Material.SAND);
		world.getBlockAt(-1,1,-1).setType(Material.SAND);
		world.getBlockAt(-1,1,0).setType(Material.SAND);
		world.getBlockAt(-1,1,1).setType(Material.SAND);
		
		List<Entity> entities = world.getEntities();
		
		for(Entity e : entities)
		{
			e.remove();
		}
	}
	
	/* (non-Javadoc)
	 * @see org.bukkit.event.world.WorldListener#onChunkLoad(org.bukkit.event.world.ChunkLoadEvent)
	 */
	public void onChunkLoad(ChunkLoadEvent e)
	{
		/*
		 * Until the Generator branch is merged, we're relegated to waiting for the server to generate and load a chunk,
		 * then immediately overwriting it with our own data. This is massively inefficient and I hate it.
		 */		
		
		// Get the chunk
		// DEBUG: Try to force lighting recalc
		e.getChunk().getBlock(0, 1, 0).setType(Material.BRICK);
		e.getChunk().getBlock(0, 1, 0).setType(Material.AIR);
		e.getWorld().refreshChunk(e.getChunk().getX(), e.getChunk().getZ());
		
		if(true) { return; }
		
		Chunk chunk = e.getChunk();
		
		// Filter out chunks further than 20 from spawn
		/*
		if(chunk.getX() > 20 || chunk.getX() < -20 || chunk.getZ() > 20 || chunk.getZ() < -20)
		{
			plugin.getServer().getWorlds().get(0).unloadChunk(chunk.getX(), chunk.getZ());
			return;
		}
		*/
		// Flatten
		World world = e.getWorld();
		String hash = world.getName()+"."+chunk.getX()+"."+chunk.getZ();
		if(!flattened.contains(hash))
		{
			flattened.add(hash);
			System.out.print("[F:"+(fCount++)+ " - " + hash + "]");
			
			CraftChunk c = (CraftChunk)chunk;
			
			this.flatten(world, c);
			
			//plugin.getServer().getWorlds().get(0).unloadChunk(c.getX(), c.getZ());
			//plugin.getServer().getWorlds().get(0).loadChunk(c.getX(), c.getZ());
		}
		else
		{
			System.out.println("[X:" + hash + "]");
		}
		
		if(chunk.getX() >= 0 || chunk.getX() < 0) { return; }
		
		if(!plugin.getChunkManager().isChunkGenerated(chunk.getWorld().getName(), chunk.getX(), chunk.getZ()))
		{
			/*
			 * Dungeonator has not yet created a chunk for this world in the specified location.
			 * We need to generate a chunk and overwrite the MC-generated chunk data
			 */
			
			plugin.getChunkManager().generateChunk(chunk.getWorld().getName(), chunk.getX(), chunk.getZ(), chunk);
		}
		else
		{
			/*
			 * This chunk has previously been generated by Dungeonator.
			 * We need to load and cache the Dungeonator-specific data to accompany the raw chunk data.
			 */
			plugin.getChunkManager().loadChunk(chunk.getWorld().getName(), chunk.getX(), chunk.getZ(), chunk);
		}
	}
	
	public void flatten(World w, Chunk c)
	{
		int worldX = 0;
		int worldZ = 0;
		
		byte[] blocks = new byte[32768];
		
		Arrays.fill(blocks, (byte)0);
		
		int pos = 0;
		for(int x = 0; x < 16; x++)
		{
			for(int z = 0; z < 16; z++)
			{
				pos = (x & 0xF) << 11 | (z & 0xF) << 7 | (plugin.py & 0x7F);
				blocks[pos] = 1;
			}
		}
		
		((CraftChunk)c).getHandle().b = blocks;
		
		// DEBUG: Try to force lighting recalc
		c.getBlock(0, 1, 0).setType(Material.BRICK);
		//c.getBlock(0, 1, 0).setType(Material.AIR);
		
		w.refreshChunk(c.getX(), c.getZ());
		for(Entity e : c.getEntities())
		{
			e.remove();
		}
		
		/*
		WorldServer ws = ((CraftWorld)w).getHandle();
		
		for(int y = 128; y > 0; --y)
		{
			for(int x = 0; x < 16; x++)
			{
				for(int z = 0; z < 16; z++)
				{
					if(y == plugin.py)
					{
						c.getBlock(x, y, z).setType(Material.BEDROCK);
					}
					else
					{
						worldX = ((c.getX() << 4) + x);
						worldZ = ((c.getZ() << 4) + z);
						
						if(w.getBlockTypeIdAt(worldX, y, worldZ) != Material.AIR.getId())
						{
							//ws.e(x, y, z, Material.AIR.getId());
							c.getBlock(x, y, z).setType(Material.AIR);
						}
					}
				}
			}
		}
		*/
	}
}
